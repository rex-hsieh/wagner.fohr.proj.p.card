# Example: Random Draws from a Population
> Randomly generate 1,000 pets, from the choices "dog", "cat", "goldfish", "monster", each with equal probability of each being chosen. Display the first few values of the resultant variable, and count the number of each type of pet.
This is a classic exercise in statistics/econometrics/any sort of scientific investigation: can I draw randomly from a population with **known** number and types of species?
The answer is: **sort of**, but **yes**. The truth is computers don't really make things randomly, but we will accept it as such because we cannot define randomness.
How do I make sure this happen?
```{r}
(pets <- c("dog", "cat", "goldfish", "monster"))  # But this only gives us the pets! We need to use the factor() data structure
help("factor")  # see what this function does!
help("sample")  # see what this function does!
pets <- factor(sample(
c("dog", "cat", "goldfish", "monster"),
1000,
replace = TRUE
)
)  # without specifying the probability vector, it is assumed to be uniform.
head(pets)
summary(pets)
```
Does the distribution (ie. the numbers of pets) closely match our initial setup? Is the distribution of pets "uniform" enough?
A slightly interesting variation: suppose we know the population is 30% dogs, 20% cat, 40% goldfish, 10% monster. We can alter the simulation slightly and get:
```{r}
pets <- factor(sample(
c("dog", "cat", "goldfish", "monster"),
1000,
replace = TRUE,
prob = c(0.3,0.2,0.4,0.1)
)
)  # without specifying the probability vector, it is assumed to be uniform.
head(pets)
summary(pets)  # total counts after simulation
pets_proportions <- (summary(pets) / 10)  # In percentage form
pets_proportions
```
One can do a lot more things with this setup: professionally/academically, we can use this do something we call *bootstrapping*. The details of this will be left to the statistics classes you will take in the future.
# Manipulating Workspace Variables
> Create some variables named after vegetables. List the names of all the variables in the user workspace that contain the letter "a".
A possible solution is the following:
```{r}
eggplant <- 1
lettuce  <- 2
tomato  <- 3
spinach  <- 4
# HINT: use ls() -- see ls() and its arugments!
```
# Some Arithmetic
> The $n$-th triangular number is given by $\frac{n(n+1)}{2}$. Create a sequence of the first 20 triangular numbers. R has a built-in constant, letters, that contains the lowercase letters of the Roman alphabet. Name the elements of the vector that you just created with the first 20 letters of the alphabet. Select the triangular numbers where the name is a vowel.
A possible solution is:
```{r}
#There are several possibilities for creating sequences, including the colon operator.
n <- 1:20
triangular <- (n * (n+1))/2
names(triangular) <- letters[n]
triangular
```
Can you rewrite the above program using the following functions:
* seq_along()
* seq_len()
```{r}
# Your attempt
```
# Diagonal Matrices
Term 1
: A **diagonal matrix** is any matrix with nonzero entries on its diagonal, but zero everywhere else. For example,
$$ \begin{bmatrix} 1 & 0 & 0 \\ 0 & 2 & 0 \\ 0 & 0 & -2 \end{bmatrix}  $$
is a $3 \times 3$ diagonal matrix.
> The diag function has several uses, one of which is to take a vector as its input and create a square matrix with that vector on the diagonal. Create a 21-by-21 matrix with the sequence -10 to 0 to 11 (i.e., -10, ... , 1, 0, 1, ,,,m 11).
I will provide a different example: I will create a $10 \times 10$ matrix with sequences -3 to 13.
```{r}
s <- -3:13
diag(s, ncol = 10, nrow = 10)
```
Try it yourself!
```{r}
# Your attempt
```
# Working With Iris
> R ships with several built-in datasets, including the famous3 iris (flowers, not eyes) data collected by Anderson and analyzed by Fisher in the 1930s. Type iris to see the dataset. Create a new data frame that consists of the numeric columns of the iris dataset, and calculate the means of its columns.
```{r}
data <- iris
data
```
# Working with Beavers
> The beaver1 and beaver2 datasets contain body temperatures of two beavers. Add a column named id to the beaver1 dataset, where the value is always 1. Similarly, add an id column to beaver2, with value 2. Vertically concatenate the two data frames and find the subset where either beaver is active.
```{r}
# Your attempt
# Use rbind() and subset() --- these will make your life easier!
```
# Working with Even and Odd Integers
This is difficult, but we will get there together:
> Write a function that accepts a vector of integers (for simplicity, you don't have to worry about input checking) and returns a logical vector that is TRUE whenever the input is even, FALSE whenever the input is odd, and NA whenever the input is nonfinite (nonfinite means anything that will make is.finite return FALSE: Inf, -Inf, NA, and NaN). Check that the function works with positive, negative, zero, and nonfinite inputs.
How does one do this? Well, we need to know that whenever a number is even, it is **divisible by 2**. So, of the vector below:
```{r}
numbers <- c(1,2,3,4,5,6,7,8,9,10)
(numbers_mod_2 <- numbers %% 2)
```
The "%%" sign means "modulo", a fancy way of saying division by some number following it. So "%% 2" means division by two, and the result it spits out is the remainder! So,
```{r}
(4 %% 3)  # = 1, because 4 = 3 x 1 + 1 !
```
So we are going to write function that takes $x$ and spits out the remainders of the elements upon division by 2!
I am going to do a variation on this exercise: I wonder if it is possible to identify odd numbers using the same method. The answer is **yes**, because odd numbers are those with remainder 1 upon division by 2 (this approach works well with small numbers, but NOT for huge numbers --- this is something we won't care much for, because the mathematical background needed for writing better algorithms is too daunting). So, I can write
```{r}
is_odd <- function(x){
x %% 2 == 1  #  Check if the remainder of x divided by 2 = 1. Remember the == operator returns a logical / boolean value!
}
is_odd(101)
is_odd(c(-5:5, Inf, -Inf, NA, NaN))
example <- cbind( values = c(-5:5, Inf, -Inf, NA, NaN), parity = is_odd(c(-5:5, Inf, -Inf, NA, NaN)) )
for (x in example$parity) {
if (x == 1) {
x = TRUE
} else {
x = FALSE
}
}
```
```{r}
is_even <- function(x) (x %% 2) == 0
is_even(c(-5:5, Inf, -Inf, NA, NaN))
```
is_odd <- function(x){
x %% 2 == 1  #  Check if the remainder of x divided by 2 = 1. Remember the == operator returns a logical / boolean value!
}
is_odd(101)
is_odd(c(-5:5, Inf, -Inf, NA, NaN))
example <- cbind( values = c(-5:5, Inf, -Inf, NA, NaN), parity = is_odd(c(-5:5, Inf, -Inf, NA, NaN)) )
for (x in example$parity) {
if (x == 1) {
x = TRUE
} else {
x = FALSE
}
}
is_odd <- function(x){
x %% 2 == 1  #  Check if the remainder of x divided by 2 = 1. Remember the == operator returns a logical / boolean value!
}
is_odd(101)
is_odd(c(-5:5, Inf, -Inf, NA, NaN))
example <- as.data.frame( cbind( values = c(-5:5, Inf, -Inf, NA, NaN), parity = is_odd(c(-5:5, Inf, -Inf, NA, NaN)) ) )
for (x in example$parity) {
if (x == 1) {
x = TRUE
} else {
x = FALSE
}
}
is_odd <- function(x){
x %% 2 == 1  #  Check if the remainder of x divided by 2 = 1. Remember the == operator returns a logical / boolean value!
}
is_odd(101)
is_odd(c(-5:5, Inf, -Inf, NA, NaN))
example <- as.data.frame( cbind( values = c(-5:5, Inf, -Inf, NA, NaN), parity = is_odd(c(-5:5, Inf, -Inf, NA, NaN)) ) )
for (x in example$parity) {
if (x == 1) {
x == TRUE
} else {
x == FALSE
}
}
is_odd <- function(x){
x %% 2 == 1  #  Check if the remainder of x divided by 2 = 1. Remember the == operator returns a logical / boolean value!
}
is_odd(101)
is_odd(c(-5:5, Inf, -Inf, NA, NaN))
example <- as.data.frame( cbind( values = c(-5:5, Inf, -Inf, NA, NaN), parity = is_odd(c(-5:5, Inf, -Inf, NA, NaN)) ) )
for (x in example$parity) {
if (x == 1) {
x <- TRUE
} else {
x <- FALSE
}
}
is_odd <- function(x){
x %% 2 == 1  #  Check if the remainder of x divided by 2 = 1. Remember the == operator returns a logical / boolean value!
}
is_odd(101)
is_odd(c(-5:5, Inf, -Inf, NA, NaN))
example <- as.data.frame( cbind( values = c(-5:5, Inf, -Inf, NA, NaN), parity = is_odd(c(-5:5, Inf, -Inf, NA, NaN)) ) )
for (x in example$parity) {
if (x == 1) {
print(TRUE)
} else {
print(FALSE)
}
}
View(example)
is_odd <- function(x){
x %% 2 == 1  #  Check if the remainder of x divided by 2 = 1. Remember the == operator returns a logical / boolean value!
}
is_odd(101)
is_odd(c(-5:5, Inf, -Inf, NA, NaN))
example <- as.data.frame( cbind( values = c(-5:5, Inf, -Inf, NA, NaN), parity = is_odd(c(-5:5, Inf, -Inf, NA, NaN)) ) )
for (x in example$parity) {
if (x == 1) {
x = "TRUE"
} else {
x = "FALSE"
}
}
is_odd <- function(x){
x %% 2 == 1  #  Check if the remainder of x divided by 2 = 1. Remember the == operator returns a logical / boolean value!
}
is_odd(101)
is_odd(c(-5:5, Inf, -Inf, NA, NaN))
example <- as.data.frame( cbind( values = c(-5:5, Inf, -Inf, NA, NaN), parity = is_odd(c(-5:5, Inf, -Inf, NA, NaN)) ) )
ifelse(example$parity = 1, TRUE, FALSE)
is_odd <- function(x){
x %% 2 == 1  #  Check if the remainder of x divided by 2 = 1. Remember the == operator returns a logical / boolean value!
}
is_odd(101)
is_odd(c(-5:5, Inf, -Inf, NA, NaN))
example <- as.data.frame( cbind( values = c(-5:5, Inf, -Inf, NA, NaN), parity = is_odd(c(-5:5, Inf, -Inf, NA, NaN)) ) )
ifelse(example$parity == 1, TRUE, FALSE)
for (x in example$parity) {
if (x == 1) {
x = "TRUE"
} else {
x = "FALSE"
}
}
ifelse(example$parity == 1, TRUE, FALSE)
example$parity <- ifelse(example$parity == 1, TRUE, FALSE)
pi
pi
# HINT: use format -- I've done most of the work here.
(format(pi, digits = 16))
#n specifies the number of scores to generate.
#It should be a natural number.
three_d6 <- function(n)
{
random_numbers <- matrix(
sample(6, 3 * n, replace = TRUE),
nrow = 3
)
colSums(random_numbers)
}
#n specifies the number of scores to generate.
#It should be a natural number.
three_d6 <- function(n){
random_numbers <- matrix(
sample(6, 3 * n, replace = TRUE),
nrow = 3
)
colSums(random_numbers)
}
three_d6(1000)
y <- three_d6(1000)
# Use the cut() function!
bonus <- cut(y,
c(2,3,5,7,12,15,17,18),
labels = -3:3
)
table <- bonus
y <- three_d6(1000)
# Use the cut() function!
bonus <- cut(y,
c(2,3,5,7,12,15,17,18),
labels = -3:3
)
(table <- bonus)
y <- three_d6(1000)
# Use the cut() function!
bonus <- cut(y,
c(2,3,5,7,12,15,17,18),
labels = -3:3
)
(table <- bonus)
(table <- bonus)
table(bonus)
y <- three_d6(1000)
# Use the cut() function!
bonus <- cut(y,
c(2,3,5,7,12,15,17,18),
labels = -3:3
)
table(bonus)
y <- three_d6(10)
# Use the cut() function!
bonus <- cut(y,
c(2,3,5,7,12,15,17,18),  # cut by UPPER BOUNDS
labels = -3:3
)
table(bonus)
y <- three_d6(1000000)
# Use the cut() function!
bonus <- cut(y,
c(2,3,5,7,12,15,17,18),  # cut by UPPER BOUNDS
labels = -3:3
)
table(bonus)
y <- three_d6(10)
# Use the cut() function!
bonus <- cut(y,
c(2,3,5,7,12,15,17,18),  # cut by UPPER BOUNDS
labels = -3:3
)
table(bonus)
setwd("~/P card reporting project")
list.of.packages <- c("readr", "tictoc", "lubridate")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
## Testing the time required by the code below--- install.packages("tictoc") if necessary
library(tictoc)
tic("everything runtime")
rm(list=ls())
setwd("~/P card reporting project")
# copy and paste the following command to the console: install.packages("readr")
# setwd("~/Documents/Random R/p card")
library(readr)
data <- read.csv("p_card_historical.csv")
data$FIN.TRANSACTION.AMOUNT <- parse_number(data$FIN.TRANSACTION.AMOUNT)
data$ACC.LAST.NAME <- as.character(data$ACC.LAST.NAME)
data$FIN.POSTING.DATE <- as.Date(data$FIN.POSTING.DATE, format = "%m/%d/%Y")
data$FIN.TRANSACTION.DATE <- as.Date(data$FIN.TRANSACTION.DATE, format = "%m/%d/%Y")
# test drive
data_may_18 <- subset(data, data$FIN.POSTING.DATE >= as.Date('2018-05-01') &
data$FIN.POSTING.DATE <= as.Date('2018-05-31'))  ## SUCCESS!!
sum_by_people_18 <- c()
( lnames <- c(unique(data_may_18$ACC.LAST.NAME)) )
for (i in 1:length(lnames)){
new_data <- subset(data_may_18, data_may_18$ACC.LAST.NAME == lnames[i])
new_sum <- sum(new_data$FIN.TRANSACTION.AMOUNT)
sum_by_people_18[i] <- as.numeric(new_sum)
}
(sum_by_people_18 <- as.data.frame(sum_by_people_18))
(rownames(sum_by_people_18) <- lnames)
(sum_by_people_18)
data_may_17 <- subset(data, data$FIN.POSTING.DATE >= as.Date('2017-05-01') &
data$FIN.POSTING.DATE <= as.Date('2017-05-31'))  ## SUCCESS!!
sum_by_people_17 <- c()
( lnames <- c(unique(data_may_17$ACC.LAST.NAME)) )
for (i in 1:length(lnames)){
new_data <- subset(data_may_17, data_may_17$ACC.LAST.NAME == lnames[i])
new_sum <- sum(new_data$FIN.TRANSACTION.AMOUNT)
sum_by_people_17[i] <- as.numeric(new_sum)
}
(sum_by_people_17 <- as.data.frame(sum_by_people_17))
(rownames(sum_by_people_17) <- lnames)
(sum_by_people_17)
# Final transformations and output -----
together <- data.frame(FY18 = numeric(), FY17 = numeric())
together_names <- c( c(data_may_18$ACC.LAST.NAME), c(data_may_17$ACC.LAST.NAME) )
(unique_together_names <- unique(together_names))
for (x in unique_together_names){
if (any(rownames(sum_by_people_18) == x)){
lnames_sum_18 <- sum_by_people_18[x,]
} else {
lnames_sum_18 <- 0
}
if (any(rownames(sum_by_people_17) == x)) {
lnames_sum_17 <- sum_by_people_17[x,]
} else {
lnames_sum_17 <- 0
}
together[x,] <- c(lnames_sum_18,lnames_sum_17)
}
(together)
png("yoy_comp/YoY_comparisons.png", width = 800, height = 600, units = 'px', res=110)
op <- par(mar=c(9,4,4,2))
ylim <- c(0, 1.5*max( max(together$FY18),max(together$FY17) ))
yoy_comparisons_plot <- barplot(t(together),names.arg = row.names(together),
horiz = FALSE,las=2, ylim = ylim, main = "YoY Comparisons for P-Cards in July",
col=c("light blue","yellow"), beside = TRUE, legend = colnames(together))
rm(op)
# text(x = yoy_comparisons_plot, y = rbind((together$FY18), (together$FY17)),
#     srt = 25, label = rbind(t(together$FY18), t(together$FY17)), pos = 3, cex = 0.8, col = "blue")
dev.off()
write.csv(together, file = "yoy_comp/YoY_comparisons_tables.csv")
toc()
list.of.packages <- c("readr", "tictoc", "lubridate")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
## Testing the time required by the code below--- install.packages("tictoc") if necessary
library(tictoc)
tic("everything runtime")
rm(list=ls())
setwd("~/P card reporting project")
# copy and paste the following command to the console: install.packages("readr")
# setwd("~/Documents/Random R/p card")
library(readr)
data <- read.csv("p_card_historical.csv")
data$FIN.TRANSACTION.AMOUNT <- parse_number(data$FIN.TRANSACTION.AMOUNT)
data$ACC.LAST.NAME <- as.character(data$ACC.LAST.NAME)
data$FIN.POSTING.DATE <- as.Date(data$FIN.POSTING.DATE, format = "%m/%d/%Y")
data$FIN.TRANSACTION.DATE <- as.Date(data$FIN.TRANSACTION.DATE, format = "%m/%d/%Y")
# test drive
data_may_18 <- subset(data, data$FIN.POSTING.DATE >= as.Date('2018-05-01') &
data$FIN.POSTING.DATE <= as.Date('2018-05-31'))  ## SUCCESS!!
sum_by_people_18 <- c()
( lnames <- c(unique(data_may_18$ACC.LAST.NAME)) )
for (i in 1:length(lnames)){
new_data <- subset(data_may_18, data_may_18$ACC.LAST.NAME == lnames[i])
new_sum <- sum(new_data$FIN.TRANSACTION.AMOUNT)
sum_by_people_18[i] <- as.numeric(new_sum)
}
(sum_by_people_18 <- as.data.frame(sum_by_people_18))
(rownames(sum_by_people_18) <- lnames)
(sum_by_people_18)
data_may_17 <- subset(data, data$FIN.POSTING.DATE >= as.Date('2017-05-01') &
data$FIN.POSTING.DATE <= as.Date('2017-05-31'))  ## SUCCESS!!
sum_by_people_17 <- c()
( lnames <- c(unique(data_may_17$ACC.LAST.NAME)) )
for (i in 1:length(lnames)){
new_data <- subset(data_may_17, data_may_17$ACC.LAST.NAME == lnames[i])
new_sum <- sum(new_data$FIN.TRANSACTION.AMOUNT)
sum_by_people_17[i] <- as.numeric(new_sum)
}
(sum_by_people_17 <- as.data.frame(sum_by_people_17))
(rownames(sum_by_people_17) <- lnames)
(sum_by_people_17)
# Final transformations and output -----
together <- data.frame(FY18 = numeric(), FY17 = numeric())
together_names <- c( c(data_may_18$ACC.LAST.NAME), c(data_may_17$ACC.LAST.NAME) )
(unique_together_names <- unique(together_names))
for (x in unique_together_names){
if (any(rownames(sum_by_people_18) == x)){
lnames_sum_18 <- sum_by_people_18[x,]
} else {
lnames_sum_18 <- 0
}
if (any(rownames(sum_by_people_17) == x)) {
lnames_sum_17 <- sum_by_people_17[x,]
} else {
lnames_sum_17 <- 0
}
together[x,] <- c(lnames_sum_18,lnames_sum_17)
}
(together)
png("yoy_comp/YoY_comparisons.png", width = 800, height = 600, units = 'px', res=110)
op <- par(mar=c(9,4,4,2))
ylim <- c(0, 1.5*max( max(together$FY18),max(together$FY17) ))
yoy_comparisons_plot <- barplot(t(together),names.arg = row.names(together),
horiz = FALSE,las=2, ylim = ylim, main = "YoY Comparisons for P-Cards in July",
col=c("light blue","yellow"), beside = TRUE, legend = colnames(together))
rm(op)
# text(x = yoy_comparisons_plot, y = rbind((together$FY18), (together$FY17)),
#     srt = 25, label = rbind(t(together$FY18), t(together$FY17)), pos = 3, cex = 0.8, col = "blue")
dev.off()
write.csv(together, file = "yoy_comp/YoY_comparisons_tables.csv")
toc()
setwd("C:/Users/mhh357/Desktop/P card reporting project")
list.of.packages <- c("readr", "tictoc", "lubridate")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
## Testing the time required by the code below--- install.packages("tictoc") if necessary
library(tictoc)
tic("everything runtime")
rm(list=ls())
setwd("C:/Users/mhh357/Desktop/P card reporting project")
# copy and paste the following command to the console: install.packages("readr")
# setwd("~/Documents/Random R/p card")
library(readr)
data <- read.csv("p_card_historical.csv")
data$FIN.TRANSACTION.AMOUNT <- parse_number(data$FIN.TRANSACTION.AMOUNT)
data$ACC.LAST.NAME <- as.character(data$ACC.LAST.NAME)
data$FIN.POSTING.DATE <- as.Date(data$FIN.POSTING.DATE, format = "%m/%d/%Y")
data$FIN.TRANSACTION.DATE <- as.Date(data$FIN.TRANSACTION.DATE, format = "%m/%d/%Y")
# test drive
data_may_18 <- subset(data, data$FIN.POSTING.DATE >= as.Date('2018-05-01') &
data$FIN.POSTING.DATE <= as.Date('2018-05-31'))  ## SUCCESS!!
sum_by_people_18 <- c()
( lnames <- c(unique(data_may_18$ACC.LAST.NAME)) )
for (i in 1:length(lnames)){
new_data <- subset(data_may_18, data_may_18$ACC.LAST.NAME == lnames[i])
new_sum <- sum(new_data$FIN.TRANSACTION.AMOUNT)
sum_by_people_18[i] <- as.numeric(new_sum)
}
(sum_by_people_18 <- as.data.frame(sum_by_people_18))
(rownames(sum_by_people_18) <- lnames)
(sum_by_people_18)
data_may_17 <- subset(data, data$FIN.POSTING.DATE >= as.Date('2017-05-01') &
data$FIN.POSTING.DATE <= as.Date('2017-05-31'))  ## SUCCESS!!
sum_by_people_17 <- c()
( lnames <- c(unique(data_may_17$ACC.LAST.NAME)) )
for (i in 1:length(lnames)){
new_data <- subset(data_may_17, data_may_17$ACC.LAST.NAME == lnames[i])
new_sum <- sum(new_data$FIN.TRANSACTION.AMOUNT)
sum_by_people_17[i] <- as.numeric(new_sum)
}
(sum_by_people_17 <- as.data.frame(sum_by_people_17))
(rownames(sum_by_people_17) <- lnames)
(sum_by_people_17)
# Final transformations and output -----
together <- data.frame(FY18 = numeric(), FY17 = numeric())
together_names <- c( c(data_may_18$ACC.LAST.NAME), c(data_may_17$ACC.LAST.NAME) )
(unique_together_names <- unique(together_names))
for (x in unique_together_names){
if (any(rownames(sum_by_people_18) == x)){
lnames_sum_18 <- sum_by_people_18[x,]
} else {
lnames_sum_18 <- 0
}
if (any(rownames(sum_by_people_17) == x)) {
lnames_sum_17 <- sum_by_people_17[x,]
} else {
lnames_sum_17 <- 0
}
together[x,] <- c(lnames_sum_18,lnames_sum_17)
}
(together)
png("yoy_comp/YoY_comparisons.png", width = 800, height = 600, units = 'px', res=110)
op <- par(mar=c(9,4,4,2))
ylim <- c(0, 1.5*max( max(together$FY18),max(together$FY17) ))
yoy_comparisons_plot <- barplot(t(together),names.arg = row.names(together),
horiz = FALSE,las=2, ylim = ylim, main = "YoY Comparisons for P-Cards in July",
col=c("light blue","yellow"), beside = TRUE, legend = colnames(together))
rm(op)
# text(x = yoy_comparisons_plot, y = rbind((together$FY18), (together$FY17)),
#     srt = 25, label = rbind(t(together$FY18), t(together$FY17)), pos = 3, cex = 0.8, col = "blue")
dev.off()
write.csv(together, file = "yoy_comp/YoY_comparisons_tables.csv")
toc()
